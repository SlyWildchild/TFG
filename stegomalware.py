import sys, os
import PIL.Image as Image

imgsize=2000 #Default image size 2000x2000

## Checks if the file at the given path is a valid image type.
# This function verifies if the file has an extension indicating it is a JPEG or PNG image.
# @param file_path Path to the file to be checked.
# @return True if the file is a JPEG or PNG image, False otherwise.
def is_valid_image(imgSrc):
    # List of valid image file extensions
    valid_image_types = ['.jpg', '.jpeg', '.png']

    # Check if the file extension matches one of the valid types
    return any(imgSrc.endswith(ext) for ext in valid_image_types)
    
## Creates a polyglot image by combining a JPEG image with a script.
# This function reads a source JPEG image and a script, then combines them into a single file.
# The combined file maintains its validity as a JPEG image while also containing the script data.
# @param imgSrc Path to the source JPEG image file.
# @param script Path to the script file to be embedded in the image.
# @param imgDst Path where the resulting polyglot image will be saved.  
def polyglot(imgSrc,script,imgDst):

    with open(imgSrc,'rb') as file: 
        bytesImgSrc = file.read();
    with open(script,'rb') as file: 
        scriptMsg = file.read();
        
    # Calculate lengths and prepare the final image
    payloadLen, itBytesImgSrc = len(scriptMsg), len(bytesImgSrc)
    tamHeader = bytesImgSrc[4] * 256 + bytesImgSrc[5]
    jpgFinal = bytearray(itBytesImgSrc + tamHeader + 291)
    jpgFinal[:4], jpgFinal[4:6], jpgFinal[6:10] = bytesImgSrc[:4], [0x01, 0x23], bytesImgSrc[6:10]

    # Header adjustment and additional filling
    for i in range(291 - tamHeader):
        jpgFinal[10 + i] = 0x01 if i < tamHeader - 6 and bytesImgSrc[10 + i] == 0x00 else bytesImgSrc[10 + i]

    # Incorporate the script into the image and finish
    jpgFinal[tamHeader + 4:tamHeader + 6] = [0x0D, 0x0A]
    jpgFinal[tamHeader + 6:tamHeader + 6 + payloadLen] = scriptMsg
    jpgFinal[tamHeader + 297:tamHeader + 297 + itBytesImgSrc - tamHeader - 4] = bytesImgSrc[10:]

    # Save the final image
    with open(imgDst,'wb') as f2: 
        f2.write(jpgFinal)  
    print(f'Image created: {imgDst}')

## Encodes a message into an image using the least significant bit (LSB) steganography method.
# This function reads a script file and encodes its content into the least significant bits of the pixel values in the source image.
# The process involves converting the message into a binary string and then modifying the least significant bits of the image's pixels to embed the message.
# @param imgSrc Path to the source image file.
# @param script Path to the script file containing the message to be encoded.
# @param imgDst Path where the encoded image will be saved.   
def encode(imgSrc,script,imgDst):
    # Read the content of the script file
    with open(script, 'rb') as file:
        scriptMsg = file.read()
    
    # Load the image
    image = Image.open(imgSrc)
    encoded_image = image.copy()
    pixels = encoded_image.load()

    # Convert the message to binary
    binary_message = ''.join([format(byte, '08b') for byte in scriptMsg])
    binary_message += '00000000' # Add 8 null bits at the end to mark the end of the message

    # Encode the message in the image (LSB method)
    msg_index = 0
    for x in range(image.width):
        for y in range(image.height):
            pixel = list(pixels[x, y])

            # Iterate over each color component (RGB)
            for n in range(3):
                if msg_index < len(binary_message):
                    # Change the LSB of the color component
                    pixel[n] = pixel[n] & ~1 | int(binary_message[msg_index])
                    msg_index += 1

            pixels[x, y] = tuple(pixel)

            if msg_index >= len(binary_message):
                break
        if msg_index >= len(binary_message):
            break

    # Save the encoded image
    encoded_image.save(imgDst)
    print(f'Image created: {imgDst}')

## Creates and saves a black image.
#  This function creates a black image of predefined size and saves it as a PNG file.
#  The size is determined by the global variable 'imgsize'.
#  @param script Name used to save the image, appended with '.png'.
#  @return The file name of the saved image.
def newImg(script):
    # Create a black image of the specified size
    img = Image.new('RGB', (imgsize, imgsize), color='black')

    # Determine the output image file name
    output_image = f'{script}.png'

    # Save the image in the current directory
    img.save(output_image, "PNG")
    
    return output_image

## Decodes a hidden message from an image using the least significant bit (LSB) steganography method.
# This function extracts a binary message hidden in the least significant bits of the pixel values in an image.
# It reconstructs the original binary message and then converts it back to text.
# @param imgSrc Path to the image file containing the hidden message.
def decode(imgSrc):
    # Load the image
    image = Image.open(imgSrc)
    pixels = image.load()
    
    binary_message = ''
    
    # Iterate over each pixel to extract the least significant bit from each color component
    for x in range(image.width):
        for y in range(image.height):
            pixel = pixels[x, y]

            for n in range(3):  # Iterate over each color component (RGB)
                # Add the least significant bit of the color component to the binary message
                binary_message += str(pixel[n] & 1)
             
        # Convert the binary message to text
    message = ''
    for i in range(0, len(binary_message), 8):
        byte = binary_message[i:i+8]
        if byte == '00000000':  # End of message indicated by 8 null bits
            break
        message += chr(int(byte, 2))
    output_file = f"{imgSrc}_hide"
    with open(output_file, 'w') as file:
        file.write(message)
    print(f'Content extracted to: {output_file}')

## Displays a help menu in the console.
# This function prints out the usage instructions for the script, explaining the different modes available
# and the expected arguments for each mode. It covers encoding, decoding, and polyglot image creation modes.    
def menu():
    print("\n Usage: stegomalware [ -e | -d | -p ] [img src] [script] [img out]")
    print("\n   -e  Encode mode     - Hide a message in a imagen");
    print("\n   -d  Decode mode     - Extract a message from an image")
    print("\n   -p  Polyglot mode   - Hide a message in a executable imagen")
    print("\n   -h  Help mode       - Show this menu");
    print("\n ------------------------")

def main(paramIn):
    try:    
        if len(sys.argv)<2:
            menu()
        else:
            if sys.argv[1] == "-e":
                if len(sys.argv)==5 and is_valid_image(paramIn[2]):
                    encode(sys.argv[2],sys.argv[3],sys.argv[4])
                    
                elif (len(sys.argv)==3):
                    coverImg = newImg(sys.argv[2])
                    imgDst = f'{sys.argv[2]}_covered.png'
                    encode(coverImg,sys.argv[2],imgDst)
                    os.remove(coverImg)
                
                else:
                  print("Usage: stegomalware -e [img src] [script] [img out]")
                  print("Usage: stegomalware -e [script]")
                  print("\n ------------------------") 
                  menu()
                  
            elif sys.argv[1] == "-p":
                if len(sys.argv)==5 and sys.argv[2].endswith('jpg') or sys.argv[2].endswith('jpeg'):
                    polyglot(sys.argv[2],sys.argv[3],sys.argv[4])
                else: 
                    print("Invalid file. Accepted JPG format")
                    print("Usage: stegomalware -p [img src.jpg] [script] [img out]")
                    print("\n ------------------------") 
                    menu()
            
            elif sys.argv[1] == "-d":
                if len(sys.argv)==3 and is_valid_image(paramIn[2]):
                    decode(sys.argv[2])
                else:
                    print("Usage: stegomalware -d [img src]")
                    print("\n ------------------------") 
                    menu()    
                              
            elif sys.argv[1] == "-h":
                menu()
                
            else:
                menu()
                
    except FileNotFoundError as e:
        print(f"File not found error: {e}")
    except PermissionError as e:
        print(f"Permission error: {e}")
    except Exception as e:
        print(f"Unexpected error: {e}")

if __name__ == "__main__":
    main(sys.argv)
