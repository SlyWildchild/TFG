import os, sys, io, math, getopt, random
from pathlib import Path 
import PIL.Image as Image
from PIL.PngImagePlugin import PngInfo

imgsize=2000 #Default image size 2000x2000
MB_IMG_DATA=imgsize*imgsize*3 #Width * height * RGB. The image will be an square to get things easier.
    
# TODO    
def polyglot(imgSrc,script,imgDst):

    with open(imgSrc,'rb') as file: 
        bytesImgSrc = file.read();
    with open(script,'rb') as file: 
        scriptMsg = file.read();
    
    # Calculo de longitudes y preparación de la imagen final
    payloadLen, leidos = len(scriptMsg), len(bytesImgSrc)
    tamCabeceraActual = bytesImgSrc[4] * 256 + bytesImgSrc[5]
    jpgFinal = bytearray(leidos + tamCabeceraActual + 291)
    jpgFinal[:4], jpgFinal[4:6], jpgFinal[6:10] = bytesImgSrc[:4], [0x01, 0x23], bytesImgSrc[6:10]

    # Ajuste de la cabecera y relleno adicional
    for i in range(291 - tamCabeceraActual):
        jpgFinal[10 + i] = 0x01 if i < tamCabeceraActual - 6 and bytesImgSrc[10 + i] == 0x00 else bytesImgSrc[10 + i]

    # Incorporación del script en la imagen y finalización
    jpgFinal[tamCabeceraActual + 4:tamCabeceraActual + 6] = [0x0D, 0x0A]
    jpgFinal[tamCabeceraActual + 6:tamCabeceraActual + 6 + payloadLen] = scriptMsg
    jpgFinal[tamCabeceraActual + 297:tamCabeceraActual + 297 + leidos - tamCabeceraActual - 4] = bytesImgSrc[10:]

    with open(imgDst,'wb') as f2: f2.write(jpgFinal)     
    
def encode(imgSrc,script,imgDst):
# Leer el contenido del archivo 'script'
    with open(script, 'rb') as file:
        scriptMsg = file.read()
    
    # Cargar la imagen
    image = Image.open(imgSrc)
    encoded_image = image.copy()
    pixels = encoded_image.load()

    # Convertir el mensaje en binario
    binary_message = ''.join([format(byte, '08b') for byte in scriptMsg])
    binary_message += '00000000' # Agregar 8 bits nulos al final para marcar el final del mensaje

    # Codificar el mensaje en la imagen (LSB)
    msg_index = 0
    for x in range(image.width):
        for y in range(image.height):
            pixel = list(pixels[x, y])

            for n in range(3): # Recorrer cada componente del color (RGB)
                if msg_index < len(binary_message): # Verificar si aún quedan bits por codificar
                    # Cambiar el LSB del componente de color
                    pixel[n] = pixel[n] & ~1 | int(binary_message[msg_index])
                    msg_index += 1

            pixels[x, y] = tuple(pixel)

            if msg_index >= len(binary_message):
                break
        if msg_index >= len(binary_message):
            break

    # Guardar la imagen codificada
    encoded_image.save(imgDst)

def decode(imgSrc):
    print("")
    # Cargar la imagen
    image = Image.open(imgSrc)
    pixels = image.load()
    
    binary_message = ''
    for x in range(image.width):
        for y in range(image.height):
            pixel = pixels[x, y]

            for n in range(3):  # Recorrer cada componente del color (RGB)
                # Agregar el bit menos significativo del componente de color al mensaje binario
                binary_message += str(pixel[n] & 1)
                
    try:    # Estomedio proporcionado
        # Convertir el mensaje binario en texto
        message = ''
        for i in range(0, len(binary_message), 8):
            byte = binary_message[i:i+8]
            if byte == '00000000':  # Si encuentra 8 bits nulos, marca el final del mensaje
                break
            message += chr(int(byte, 2))
            output = f"{imgSrc}_hide.txt"
            with open(output, 'w') as file:
                file.write(message)
                
    except: # Estomedio generado
        message = bytearray([pixel for tuple in list(image.getdata()) for pixel in tuple])
        output = f"{imgSrc}_hide.txt"
        with open(output, 'ab') as file:
            file.write(message)

def newImg(script): #Will open a file in raw mode and then generate as much as needed images to store the file.
    global imgsize
    with open(script, "rb") as file:
        raw_data=bytearray()
        while (byte := file.read(1)):
            raw_data+=byte  
        raw_data+=bytearray(bytes(MB_IMG_DATA - len(raw_data))) #Padding \x00's till completed
        # Create the image
        img = Image.frombytes("RGB", (imgsize, imgsize), bytes(raw_data))

        # Simplified image name
        image = f'{script}_covered.png'
    
        # Save the image in the current directory
        img.save(image, "PNG")

        print(f'Image created: {image}')
    
def menu():
    print("\n Usage: stegomalware [ -e | -d | -p ] [img src] [script] [img out]")
    print("\n   -e  Encode mode - Hide a message in a imagen");
    print("\n   -d  Decode mode - Extract a message from an image")
    print("\n   -p  Polyglot mode - Hide a message in a executable imagen")
    print("\n ------------------------")

def main(paramIn):
    
    if len(sys.argv)<2:
        menu()
    else:
        if sys.argv[1] == "-e":
            if len(sys.argv)==5:
                # message = read_message_from_file(sys.argv[3]) 
                encode(sys.argv[2],sys.argv[3],sys.argv[4])
            elif (len(sys.argv)==3):
                # TODO
                newImg(sys.argv[2])

        elif sys.argv[1] == "-p" and len(sys.argv)==5:
                # TODO
            if sys.argv[2].endswith('jpg'):
                polyglot(sys.argv[2],sys.argv[3],sys.argv[4])
                print("")
            else: 
                print("Invalid file. Accepted JPG format")
                menu()
        
        elif sys.argv[1] == "-d" and len(sys.argv)==3:
            # TODO
            #if sys.argv[3].endswith('png'):
               message = decode(sys.argv[2])
               print(message)
            

        else:
            menu()

main(sys.argv)
