import sys
import PIL.Image as Image

imgsize=2000 #Default image size 2000x2000
MB_IMG_DATA=imgsize*imgsize*3 #Width * height * RGB

## Checks if the file at the given path is a valid image type.
# This function verifies if the file has an extension indicating it is a JPEG or PNG image.
# @param file_path Path to the file to be checked.
# @return True if the file is a JPEG or PNG image, False otherwise.
def is_valid_image(imgSrc):
    # List of valid image file extensions
    valid_image_types = ['.jpg', '.jpeg', '.png']

    # Check if the file extension matches one of the valid types
    return any(imgSrc.endswith(ext) for ext in valid_image_types)
    
## Creates a polyglot image by combining a JPEG image with a script.
# This function reads a source JPEG image and a script, then combines them into a single file.
# The combined file maintains its validity as a JPEG image while also containing the script data.
# @param imgSrc Path to the source JPEG image file.
# @param script Path to the script file to be embedded in the image.
# @param imgDst Path where the resulting polyglot image will be saved.  
def polyglot(imgSrc,script,imgDst):

    with open(imgSrc,'rb') as file: 
        bytesImgSrc = file.read();
    with open(script,'rb') as file: 
        scriptMsg = file.read();
    
    # Calculate lengths and prepare the final image
    payloadLen, leidos = len(scriptMsg), len(bytesImgSrc)
    tamCabeceraActual = bytesImgSrc[4] * 256 + bytesImgSrc[5]
    jpgFinal = bytearray(leidos + tamCabeceraActual + 291)
    jpgFinal[:4], jpgFinal[4:6], jpgFinal[6:10] = bytesImgSrc[:4], [0x01, 0x23], bytesImgSrc[6:10]

    # Header adjustment and additional filling
    for i in range(291 - tamCabeceraActual):
        jpgFinal[10 + i] = 0x01 if i < tamCabeceraActual - 6 and bytesImgSrc[10 + i] == 0x00 else bytesImgSrc[10 + i]

    # Incorporate the script into the image and finish
    jpgFinal[tamCabeceraActual + 4:tamCabeceraActual + 6] = [0x0D, 0x0A]
    jpgFinal[tamCabeceraActual + 6:tamCabeceraActual + 6 + payloadLen] = scriptMsg
    jpgFinal[tamCabeceraActual + 297:tamCabeceraActual + 297 + leidos - tamCabeceraActual - 4] = bytesImgSrc[10:]

    # Save the final image
    with open(imgDst,'wb') as f2: 
        f2.write(jpgFinal)     

## Encodes a message into an image using the least significant bit (LSB) steganography method.
# This function reads a script file and encodes its content into the least significant bits of the pixel values in the source image.
# The process involves converting the message into a binary string and then modifying the least significant bits of the image's pixels to embed the message.
# @param imgSrc Path to the source image file.
# @param script Path to the script file containing the message to be encoded.
# @param imgDst Path where the encoded image will be saved.   
def encode(imgSrc,script,imgDst):
    # Read the content of the script file
    with open(script, 'rb') as file:
        scriptMsg = file.read()
    
    # Load the image
    image = Image.open(imgSrc)
    encoded_image = image.copy()
    pixels = encoded_image.load()

    # Convert the message to binary
    binary_message = ''.join([format(byte, '08b') for byte in scriptMsg])
    binary_message += '00000000' # Add 8 null bits at the end to mark the end of the message

    # Encode the message in the image (LSB method)
    msg_index = 0
    for x in range(image.width):
        for y in range(image.height):
            pixel = list(pixels[x, y])

            # Iterate over each color component (RGB)
            for n in range(3):
                if msg_index < len(binary_message):
                    # Change the LSB of the color component
                    pixel[n] = pixel[n] & ~1 | int(binary_message[msg_index])
                    msg_index += 1

            pixels[x, y] = tuple(pixel)

            if msg_index >= len(binary_message):
                break
        if msg_index >= len(binary_message):
            break

    # Save the encoded image
    encoded_image.save(imgDst)

## Generates a new image from raw data contained in a file.
# This function reads the contents of a specified file in raw mode, pads the data with null bytes if necessary, 
# and then generates an image using this data. The image is saved in the PNG format.
# @param script Path to the file containing the raw data to be converted into an image.
def encode_newImg(script):
    # Read the contents of the file
    with open(script, "rb") as file:
        raw_data=bytearray()
        while (byte := file.read(1)):
            raw_data+=byte  
        raw_data+=bytearray(bytes(MB_IMG_DATA - len(raw_data))) # Padding with null bytes
        
        # Create the image from raw data
        img = Image.frombytes("RGB", (imgsize, imgsize), bytes(raw_data))

        # Determine the output image name
        image = f'{script}_covered.png'
    
        # Save the image in the current directory
        img.save(image, "PNG")

        print(f'Image created: {image}')

## Decodes a hidden message from an image using the least significant bit (LSB) steganography method.
# This function extracts a binary message hidden in the least significant bits of the pixel values in an image.
# It reconstructs the original binary message and then converts it back to text.
# @param imgSrc Path to the image file containing the hidden message.
def decode(imgSrc):
    # Load the image
    image = Image.open(imgSrc)
    pixels = image.load()
    
    binary_message = ''
    
    # Iterate over each pixel to extract the least significant bit from each color component
    for x in range(image.width):
        for y in range(image.height):
            pixel = pixels[x, y]

            for n in range(3):  # Iterate over each color component (RGB)
                # Add the least significant bit of the color component to the binary message
                binary_message += str(pixel[n] & 1)
                
    try:    # Estomedio proporcionado
        # Convert the binary message to text
        message = ''
        for i in range(0, len(binary_message), 8):
            byte = binary_message[i:i+8]
            if byte == '00000000':  # End of message indicated by 8 null bits
                break
            message += chr(int(byte, 2))
            output_file = f"{imgSrc}_hide"
            with open(output_file, 'w') as file:
                file.write(message)
        print(f'Content extracted to: {output_file}')
                
    except: # Estomedio generado
        raw_data = bytearray()
        for y in range(image.height):
            for x in range(image.width):
                pixel = pixels[x, y]
                raw_data += bytearray(pixel)
        raw_data = raw_data[:MB_IMG_DATA]
        output_file = f'{imgSrc}_extracted'
        with open(output_file, 'wb') as file:
            file.write(raw_data)
        print(f'Content extracted to: {output_file}')
    
## Displays a help menu in the console.
# This function prints out the usage instructions for the script, explaining the different modes available
# and the expected arguments for each mode. It covers encoding, decoding, and polyglot image creation modes.    
def menu():
    print("\n Usage: stegomalware [ -e | -d | -p ] [img src] [script] [img out]")
    print("\n   -e  Encode mode     - Hide a message in a imagen");
    print("\n   -d  Decode mode     - Extract a message from an image")
    print("\n   -p  Polyglot mode   - Hide a message in a executable imagen")
    print("\n   -h  Help mode       - Show this menu");
    print("\n ------------------------")

def main(paramIn):
    try:    
        if len(sys.argv)<2:
            menu()
        else:
            if sys.argv[1] == "-e":
                if len(sys.argv)==5 and is_valid_image(paramIn[2]):
                    encode(sys.argv[2],sys.argv[3],sys.argv[4])
                    
                elif (len(sys.argv)==3):
                    encode_newImg(sys.argv[2])
                
                else:
                  print("Usage: stegomalware -e [img src] [script] [img out]")
                  print("Usage: stegomalware -e [script]")
                  print("\n ------------------------") 
                  menu()
                  
            elif sys.argv[1] == "-p":
                if len(sys.argv)==5 and sys.argv[2].endswith('jpg') or sys.argv[2].endswith('jpeg'):
                    polyglot(sys.argv[2],sys.argv[3],sys.argv[4])
                else: 
                    print("Invalid file. Accepted JPG format")
                    print("Usage: stegomalware -p [img src.jpg] [script] [img out]")
                    print("\n ------------------------") 
                    menu()
            
            elif sys.argv[1] == "-d":
                if len(sys.argv)==3 and is_valid_image(paramIn[2]):
                    decode(sys.argv[2])
                else:
                    print("Usage: stegomalware -d [img src]")
                    print("\n ------------------------") 
                    menu()    
                              
            elif sys.argv[1] == "-h":
                menu()
                
            else:
                menu()
                
    except FileNotFoundError as e:
        print(f"File not found error: {e}")
    except PermissionError as e:
        print(f"Permission error: {e}")
    except Exception as e:
        print(f"Unexpected error: {e}")

if __name__ == "__main__":
    main(sys.argv)
