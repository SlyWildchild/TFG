import os, sys, io, math, getopt, random
from pathlib import Path 
import PIL.Image as Image
from PIL.PngImagePlugin import PngInfo

imgsize=2000 #Default image size 2000x2000
MB_IMG_DATA=imgsize*imgsize*3 #Width * height * RGB

## Checks if a specified file exists in the file system.
# This function uses the os.path.exists method to determine whether a given file path refers to an existing file.
# @param file Path of the file to check.
# @return True if the file exists, False otherwise.
def file_exists(file):
    return os.path.exists(file)

## Checks if the file at the given path is a valid image type.
# This function verifies if the file has an extension indicating it is a JPEG or PNG image.
# @param file_path Path to the file to be checked.
# @return True if the file is a JPEG or PNG image, False otherwise.
def is_valid_image(file_path):
    # List of valid image file extensions
    valid_image_types = ['.jpg', '.jpeg', '.png']

    # Check if the file extension matches one of the valid types
    return any(file_path.endswith(ext) for ext in valid_image_types)
    
## Creates a polyglot image by combining a JPEG image with a script.
# This function reads a source JPEG image and a script, then combines them into a single file.
# The combined file maintains its validity as a JPEG image while also containing the script data.
# @param imgSrc Path to the source JPEG image file.
# @param script Path to the script file to be embedded in the image.
# @param imgDst Path where the resulting polyglot image will be saved.  
def polyglot(imgSrc,script,imgDst):

    with open(imgSrc,'rb') as file: 
        bytesImgSrc = file.read();
    with open(script,'rb') as file: 
        scriptMsg = file.read();
    
    # Calculate lengths and prepare the final image
    payloadLen, leidos = len(scriptMsg), len(bytesImgSrc)
    tamCabeceraActual = bytesImgSrc[4] * 256 + bytesImgSrc[5]
    jpgFinal = bytearray(leidos + tamCabeceraActual + 291)
    jpgFinal[:4], jpgFinal[4:6], jpgFinal[6:10] = bytesImgSrc[:4], [0x01, 0x23], bytesImgSrc[6:10]

    # Header adjustment and additional filling
    for i in range(291 - tamCabeceraActual):
        jpgFinal[10 + i] = 0x01 if i < tamCabeceraActual - 6 and bytesImgSrc[10 + i] == 0x00 else bytesImgSrc[10 + i]

    # Incorporate the script into the image and finish
    jpgFinal[tamCabeceraActual + 4:tamCabeceraActual + 6] = [0x0D, 0x0A]
    jpgFinal[tamCabeceraActual + 6:tamCabeceraActual + 6 + payloadLen] = scriptMsg
    jpgFinal[tamCabeceraActual + 297:tamCabeceraActual + 297 + leidos - tamCabeceraActual - 4] = bytesImgSrc[10:]

    # Save the final image
    with open(imgDst,'wb') as f2: 
        f2.write(jpgFinal)     

## Encodes a message into an image using the least significant bit (LSB) steganography method.
# This function reads a script file and encodes its content into the least significant bits of the pixel values in the source image.
# The process involves converting the message into a binary string and then modifying the least significant bits of the image's pixels to embed the message.
# @param imgSrc Path to the source image file.
# @param script Path to the script file containing the message to be encoded.
# @param imgDst Path where the encoded image will be saved.   
def encode(imgSrc,script,imgDst):
    # Read the content of the script file
    with open(script, 'rb') as file:
        scriptMsg = file.read()
    
    # Load the image
    image = Image.open(imgSrc)
    encoded_image = image.copy()
    pixels = encoded_image.load()

    # Convert the message to binary
    binary_message = ''.join([format(byte, '08b') for byte in scriptMsg])
    binary_message += '00000000' # Add 8 null bits at the end to mark the end of the message

    # Encode the message in the image (LSB method)
    msg_index = 0
    for x in range(image.width):
        for y in range(image.height):
            pixel = list(pixels[x, y])

            # Iterate over each color component (RGB)
            for n in range(3):
                if msg_index < len(binary_message):
                    # Change the LSB of the color component
                    pixel[n] = pixel[n] & ~1 | int(binary_message[msg_index])
                    msg_index += 1

            pixels[x, y] = tuple(pixel)

            if msg_index >= len(binary_message):
                break
        if msg_index >= len(binary_message):
            break

    # Save the encoded image
    encoded_image.save(imgDst)

## Decodes a hidden message from an image using the least significant bit (LSB) steganography method.
# This function extracts a binary message hidden in the least significant bits of the pixel values in an image.
# It reconstructs the original binary message and then converts it back to text.
# @param imgSrc Path to the image file containing the hidden message.
def decode(imgSrc):
    print("")
    # Load the image
    image = Image.open(imgSrc)
    pixels = image.load()
    
    binary_message = ''
    
    # Iterate over each pixel to extract the least significant bit from each color component
    for x in range(image.width):
        for y in range(image.height):
            pixel = pixels[x, y]

            for n in range(3):  # Iterate over each color component (RGB)
                # Add the least significant bit of the color component to the binary message
                binary_message += str(pixel[n] & 1)
                
    try:    # Estomedio proporcionado
        # Convert the binary message to text
        message = ''
        for i in range(0, len(binary_message), 8):
            byte = binary_message[i:i+8]
            if byte == '00000000':  # End of message indicated by 8 null bits
                break
            message += chr(int(byte, 2))
            output = f"{imgSrc}_hide.txt"
            with open(output, 'w') as file:
                file.write(message)
                
    except: # Estomedio generado
        message = bytearray([pixel for tuple in list(image.getdata()) for pixel in tuple])
        output = f"{imgSrc}_hide.txt"
        with open(output, 'ab') as file:
            file.write(message)

## Generates a new image from raw data contained in a file.
# This function reads the contents of a specified file in raw mode, pads the data with null bytes if necessary, 
# and then generates an image using this data. The image is saved in the PNG format.
# @param script Path to the file containing the raw data to be converted into an image.
def newImg(script):
    # Read the contents of the file
    with open(script, "rb") as file:
        raw_data=bytearray()
        while (byte := file.read(1)):
            raw_data+=byte  
        raw_data+=bytearray(bytes(MB_IMG_DATA - len(raw_data))) # Padding with null bytes
        
        # Create the image from raw data
        img = Image.frombytes("RGB", (imgsize, imgsize), bytes(raw_data))

        # Determine the output image name
        image = f'{script}_covered.png'
    
        # Save the image in the current directory
        img.save(image, "PNG")

        print(f'Image created: {image}')

## Displays a help menu in the console.
# This function prints out the usage instructions for the script, explaining the different modes available
# and the expected arguments for each mode. It covers encoding, decoding, and polyglot image creation modes.    
def menu():
    print("\n Usage: stegomalware [ -e | -d | -p ] [img src] [script] [img out]")
    print("\n   -e  Encode mode - Hide a message in a imagen");
    print("\n   -d  Decode mode - Extract a message from an image")
    print("\n   -p  Polyglot mode - Hide a message in a executable imagen")
    print("\n ------------------------")


def main(paramIn):
    
    if len(sys.argv)<2:
        menu()
    else:
        if sys.argv[1] == "-e":
            if len(sys.argv)==5:
                # message = read_message_from_file(sys.argv[3]) 
                encode(sys.argv[2],sys.argv[3],sys.argv[4])
            elif (len(sys.argv)==3):
                # TODO
                newImg(sys.argv[2])

        elif sys.argv[1] == "-p" and len(sys.argv)==5:
                # TODO
            if sys.argv[2].endswith('jpg'):
                polyglot(sys.argv[2],sys.argv[3],sys.argv[4])
                print("")
            else: 
                print("Invalid file. Accepted JPG format")
                menu()
        
        elif sys.argv[1] == "-d" and len(sys.argv)==3:
            # TODO
            #if sys.argv[3].endswith('png'):
               message = decode(sys.argv[2])
               print(message)
            

        else:
            menu()

main(sys.argv)
